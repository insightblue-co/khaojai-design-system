import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read the Figma exported styles
const figmaStylesPath = path.join(__dirname, "../figma/exported-styles.json");
const figmaStyles: Record<string, string> = JSON.parse(
  fs.readFileSync(figmaStylesPath, "utf-8")
);

// Helper to convert Figma key to TypeScript variable name
// "Brand/500" -> "Brand500"
// "Gray (light mode)/25" -> "GrayLightMode25"
// "Blue dark/500" -> "BlueDark500"
function toTsVariableName(key: string): string {
  return key
    .replace(/[()]/g, "") // Remove parentheses
    .replace(/\s+/g, "") // Remove spaces
    .replace(/\//g, "") // Remove slashes
    .replace(/-/g, ""); // Remove hyphens
}

// Helper to convert Figma category to Tailwind color key
// "Brand" -> "brand"
// "Gray (light mode)" -> "grayLight"
// "Gray (dark mode)" -> "grayDark"
// "Blue light" -> "blueLight"
// "Blue dark" -> "blueDark"
function toTailwindColorKey(category: string): string {
  return category
    .replace(/\(light mode\)/gi, "Light")
    .replace(/\(dark mode\)/gi, "Dark")
    .replace(/[()]/g, "")
    .replace(/\s+/g, "")
    .replace(/-/g, "")
    .replace(/^./, (c) => c.toLowerCase());
}

// Helper to format a comment from the original key
function formatComment(key: string): string {
  const [category, shade] = key.split("/");
  if (shade) {
    return `${category} - shade ${shade}`;
  }
  return category;
}

// Categories to skip (not design tokens)
const skipCategories = ["Avatar user square"];

// Filter and group colors by category
interface ColorGroup {
  [shade: string]: string;
}

interface GroupedColors {
  [category: string]: ColorGroup;
}

const groupedColors: GroupedColors = {};
const flatColors: Array<{ key: string; varName: string; value: string }> = [];

for (const [key, value] of Object.entries(figmaStyles)) {
  // Skip avatar colors
  if (skipCategories.some((skip) => key.startsWith(skip))) {
    continue;
  }

  const parts = key.split("/");
  if (parts.length !== 2) {
    // Handle base colors like "Base/White"
    const varName = toTsVariableName(key);
    flatColors.push({ key, varName, value });
    
    // Add to grouped colors for Tailwind
    const category = parts[0];
    const tailwindKey = toTailwindColorKey(category);
    if (!groupedColors[tailwindKey]) {
      groupedColors[tailwindKey] = {};
    }
    if (parts.length === 2) {
      groupedColors[tailwindKey][parts[1]] = value;
    } else {
      // For single-value colors like Base/White, store as DEFAULT
      groupedColors[tailwindKey]["DEFAULT"] = value;
    }
    continue;
  }

  const [category, shade] = parts;
  const varName = toTsVariableName(key);
  flatColors.push({ key, varName, value });

  // Group for Tailwind
  const tailwindKey = toTailwindColorKey(category);
  if (!groupedColors[tailwindKey]) {
    groupedColors[tailwindKey] = {};
  }
  groupedColors[tailwindKey][shade] = value;
}

// Generate TypeScript colors file
function generateColorsTs(): string {
  const lines: string[] = [
    "// This file is auto-generated by scripts/generate-tokens.ts",
    "// Do not edit manually. Update figma/exported-styles.json and run `pnpm generate`",
    "",
    "// =============================================================================",
    "// Color Tokens",
    "// =============================================================================",
    "",
  ];

  // Group exports by category for better organization
  let currentCategory = "";
  for (const { key, varName, value } of flatColors) {
    const category = key.split("/")[0];
    if (category !== currentCategory) {
      if (currentCategory !== "") {
        lines.push("");
      }
      lines.push(`// ${category}`);
      currentCategory = category;
    }
    lines.push(`/** ${formatComment(key)} */`);
    lines.push(`export const ${varName} = "${value}" as const;`);
  }

  // Add a colors object for convenient access
  lines.push("");
  lines.push("// =============================================================================");
  lines.push("// Colors Object (for dynamic access)");
  lines.push("// =============================================================================");
  lines.push("");
  lines.push("export const colors = {");
  
  for (const { varName, value } of flatColors) {
    lines.push(`  ${varName}: "${value}",`);
  }
  
  lines.push("} as const;");
  lines.push("");
  lines.push("export type ColorToken = keyof typeof colors;");
  lines.push("export type ColorValue = (typeof colors)[ColorToken];");
  lines.push("");

  return lines.join("\n");
}

// Generate Tailwind preset file
function generateTailwindPreset(): string {
  const lines: string[] = [
    "// This file is auto-generated by scripts/generate-tokens.ts",
    "// Do not edit manually. Update figma/exported-styles.json and run `pnpm generate`",
    "",
    'import type { Config } from "tailwindcss";',
    "",
    "// =============================================================================",
    "// Tailwind Color Palette",
    "// =============================================================================",
    "",
    "export const colors = {",
  ];

  // Sort categories for consistent output
  const sortedCategories = Object.keys(groupedColors).sort();

  for (const category of sortedCategories) {
    const shades = groupedColors[category];
    const shadeEntries = Object.entries(shades);

    if (shadeEntries.length === 1 && shadeEntries[0][0] === "DEFAULT") {
      // Single value color
      lines.push(`  ${category}: "${shadeEntries[0][1]}",`);
    } else {
      // Multi-shade color
      lines.push(`  ${category}: {`);
      
      // Sort shades numerically if possible
      const sortedShades = shadeEntries.sort((a, b) => {
        const numA = parseInt(a[0], 10);
        const numB = parseInt(b[0], 10);
        if (!isNaN(numA) && !isNaN(numB)) {
          return numA - numB;
        }
        return a[0].localeCompare(b[0]);
      });

      for (const [shade, value] of sortedShades) {
        lines.push(`    "${shade}": "${value}",`);
      }
      lines.push("  },");
    }
  }

  lines.push("} as const;");
  lines.push("");
  lines.push("// =============================================================================");
  lines.push("// Khaojai Tailwind Preset");
  lines.push("// =============================================================================");
  lines.push("");
  lines.push("export const khaojaiPreset: Partial<Config> = {");
  lines.push("  theme: {");
  lines.push("    extend: {");
  lines.push("      colors,");
  lines.push("    },");
  lines.push("  },");
  lines.push("};");
  lines.push("");
  lines.push("export default khaojaiPreset;");
  lines.push("");

  return lines.join("\n");
}

// Ensure output directories exist
const tokensDir = path.join(__dirname, "../src/tokens");
const tailwindDir = path.join(__dirname, "../src/tailwind");

fs.mkdirSync(tokensDir, { recursive: true });
fs.mkdirSync(tailwindDir, { recursive: true });

// Write files
const colorsContent = generateColorsTs();
const presetContent = generateTailwindPreset();

fs.writeFileSync(path.join(tokensDir, "colors.ts"), colorsContent);
fs.writeFileSync(path.join(tailwindDir, "preset.ts"), presetContent);

console.log("✅ Generated src/tokens/colors.ts");
console.log("✅ Generated src/tailwind/preset.ts");
console.log(`   Total color tokens: ${flatColors.length}`);
console.log(`   Color categories: ${Object.keys(groupedColors).length}`);
